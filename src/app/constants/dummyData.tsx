export const dummyText = [
    { id: 1, text: "수업 시작하겠습니다. 일단 저기 제가 저기 홈페이지에 일단 공지는 했는데 지금 중간고사 중간고사죠.중간고사 과제가 2주 뒤에 2주 뒤에 2주 뒤에 지금 저희가 오늘이 6주차 수업이거든요.그래서 이제 6주 차라서 2주 뒤면 이제 4월 26일이죠.예 그래서 4월 26일 수업 시간이죠. 12시부터 12시 50분까지 저희 이제 중간고사를 볼 겁니다.거고 그다음에 이제 문제 형태야 ox 문제부터 객관식 주관식 주관식부터 단답형 서술형 다 섞어서 두루두제 15분은 " },
    { id: 2, text: "그러니까 시험 치고 이제 원래 뭐예요? 제 수업 들어본 학생은 알겠지만 저는 뭐죠? 저기 일단은 15분 동안에는 못 나간다 이거죠. 15분 동안은 못 나가고 15분이 되면 제출하고 나가실 수가 있는데 그렇기 때문에 늦게 오는 학생이 있을 수 있잖아요. 늦게 오는 근데 이제 이게 나가는 학생이 생기면 들어올 수가 없어 무슨 말인지 알겠죠 나간 학생이 생기면 들어올 수가 없습니다. 그래서 15분 이후에는 입실이 불가능합니다. 그래서 시험은 지각을 하더라도 15분이 넘어가면 이게 여러 분도 입실이 안 되니까 중간고사에 공시가 안 됐다. 그거는 주의해야 될 사항으로 알고 계시면 될 것 같네요. 궁금한 건 특별한 건 없죠. 어차피 다음 주까지 수업한 내용을 이제 2주 뒤에 중간고사 친다 정도로 이해하면 될 것 같고요. 일단 여기까지 하고 오늘 수업 시작하겠습니다." },
    { id: 3, text: "오늘은 저기 슬라이드가 저기 한 개가 아니고 다음 주까지 슬라이드를 1개로 지금 묶었는데 이유가 뭐냐고 하면 이거 원래 스케줄을 한번 보시면 이번 주 다음 주 이제 스파크 설치하고 하도 설치하고 진행을 했어야 됐는데 이게 이제 무슨 문제가 있는지를 제가 먼저 말씀을 좀 드리면 원래는 이렇게 하면 되지 원래는 이렇게 하면 되는데 저희가 지금 여기 이 중에 저기 애플 노트북 손 들어보세요. 애플 특히 대부분 에몬이겠지 인테 인텔 애플 노트북에 있는 사람 없겠지 몇 명 있긴 할 거야. 근데 이제 이 애플 실리콘이라고 그러죠. 요 애플 실리콘 이 다른 건 다 좋은데 지금 가상 머신 버추얼박스 같은 게 지금 제대로 안 돌아요." },
    { id: 4, text: "가상화 지금 m1이 지금 올해 지금 지금이 m3죠 지금 m3라서 나온 지 한 대충 봐서 한 3년 됐거든요. 3년이 됐는데 지금 아직 거의 이제 한 2년 좀 넘어가지고 이제 리눅스 깔 수 있어 애플 실리콘이 리눅스를 네이티브로 깔기에 거의 불가능했다고 이거죠. 그래서 최근에 아마 6개월 이내에 지금 이제 이제 해킹해가지고 이제 리눅스 m원에다가 리눅스 네이티브를 깔 수 있는 기법이 이제 공개가 됐어 2년 반 동안 불가능하다고 그다음에 버트 박스나 이런 것들이 나와는 있는데 아직 이제 정식 버전이 아니라 가상화 쪽을 이제 역시 애플 실리콘으로 하려면 역시 문제가 있어. 근데 우리 수업은 리눅스 기반으로 돌려야 되거든요. 원래 그래서 도커 말고는 지금 별로 대안이 없어 그래서 그래서 이제 뭐가 문제냐면 제가 이제 설치하는 법을 알려드리고 하면 되는데 이게 이제 애플은 따로 해야 돼 그 이야기죠." },
    { id: 5, text: "그 이전에는 그냥 뭐예요? 버트 박스 깔고 그냥 쭉 갑니다 하면 끝이었는데 지금 작년부터는 이제 이게 이제 거의 불가능한 상태가 돼서 애플은 따로 가고 이제 그러니까 애플 빼고 나머지 인텔 따로 가고 하는 이제 이런 상황이 됐다는 거죠.  그래서 수업이 두 번 해야 돼 두 번 더 해야 되고 그래서 조금은 이제 문제가 생겼다는 거지 그래서 제가 설치하는 데 시간이 좀 걸리고 하기 때문에 제가 그냥 아예 중간고사 이후로 설치하는 거를 조금 순서를 바꾼 거죠. 그래가지고 이제 요 뒷부분에 하게 되고 그래서 저희가 원래 이제 중간고사 이후에 했던 스타트 ql을 오늘 할 것 아니겠어요? 오늘하고 내일 다음 주입니다. 다음 주 2주에 걸쳐서 스파크 SQL을 어떻게 실습을 하고 그다음에 진행을 할 겁니다. 근데 사실은 이거 이미 이야기드렸지만 요즘 주류는 뭐죠? 스파크 안에서도 스파크 RDD가 아니고 스파크 SQL이 주주라고 했죠. 그래서 요즘 빅데이터 만든다라고 하면 주로 이제 이 스파크 SQL을 주로 쓰 하는 게 메인이다 보니까 여기에 대한 이야기를 오늘 하고 다음 주까지 이야기를 할 거다." },
    { id: 6, text: "먼저 그다음에 이제 설치하고 뒷부분 가고 하는 거는 이제 중간고사 이후에 진행하도록 하겠습니다. 일단 이거 먼저 이제 상황을 말씀드린 거 스케줄도 이제 그대로 거기에 맞춰가지고 이미 돼 있으니까 작년에 하고 약간 다른 게 이제 이런 부분이다 하고 먼저 말씀드립니다. 이게 결국은 리눅스 환경을 사실 제일 간단하게 하려면 여러분 클라우드 쓰시면 되죠. 클라우드 쓰시면 되는데 클라우드가 이렇게 무료 클라우드 쓸 수는 있는데 제일 좋은 거는 여러분들이 컴퓨터에서 직접 이제 설치하고 환경 만들고 하는 게 사실은 중요한 수업의 내용이기 때문에 그런 식으로 진행하겠다라고 이해하시면 될 것 같아요. 다음으로 갑시다. 그래서 이제 오늘 할 내용은 스파 SQL 파트1이죠. 그래서 파트 1에 대해서 할 텐데 일단은 스파크 SQL이 스파크 RDD하고 뭐가 다른지를 먼저 이야기를 해야 되는데 이미 사실은 저희가 뭐죠?" },
    { id: 7, text: "그래프 하나 보여드렸죠. 잠시만 이게 아니고 4강이구나 4강 잠깐만요. 사강이 어딨나 제가 이제 그래프 보여드린 게 그거잖아요. 스파크가 특이한 게 파이썬으로 돌리는 스파크랑 스카라로 돌리는 스파크가 속도가 다르다는 이야기를 했죠. 속도가 다르고 속도 다른 건 이제 우리 다음 주에 사실은 과제가 나올 겁니다. 원래 오늘 과제를 내려고 그랬는데 저도 통상적으로 과제가 나가면 저기 2주 있다가 제출해야 되거든요. 근데 오늘 과제가 나가면 무슨 문제가 생기지 오늘 과제가 나가면 중간고사가 2주 되니까 이제 여러분들 중간고사도 하면서 과제도 해야 되는 문제가 생기잖아요. 그래서 과제는 다음 주에 낼게요. 예 그러면 이제 중간고사 하고 나서 다음 주에 이제 과제를 제출하셔야 되는데 일단은 말씀드린 대로 지난 시간에는 저희가 실습한 게 스칼라 파이 파이썬과 이제 저기 죄송합니다. 스칼라 스파크 그리고 파이썬으로 이제 역시 똑같이 돌리는 워드 카운트 예제를 지난 시간에 실습을 했잖아요." },
    { id: 8, text: "그래프가 뭐였죠? 그래프가 뭐고요? 그냥 스파크 스칼라 스파크로 돌 알기죠? 송화기는 하면 4초 정도 걸리는데 파이썬 스파크 RDD로 하면 9초 정도 걸린다. 4초 9초 차이였죠. 여기 스칼라로 돌리는 게 파이썬으로 돌리는 것보다 속도가 이제 좀 2배 정도 이상 빠르기 때문에 당연히 똑같은 조건이라면 스칼라로 돌리는 게 낫다는 이야기죠. 그런데 이거는 이제 스칼라 RDD 기준으로 그런데 이제 오늘 배울 이제 스파크 SQL로 돌리면 얘가 이제 2초쯤 된다는 거죠." },
    { id: 9, text: "무슨 이야기를 드리냐면 결국은 RDD라는 걸 우리가 지난 시간에 배웠는데 RDD로 돌리는 것보다 스파크 SQL로 돌리면 속도가 더 점프가 2배 10% 20% 빨라요가 아니고 지금 공식 사이트 기준으로 2배 정도 빠르다고 지금 나오고 있기 때문에 당연히 이제 근데 여기는 이제 미세하게 언노드 차이는 거의 없는 걸로 온다는 거지 그러면 이제 스칼라를 새로 배우는 게 낫니 파이썬으로 하는 게 낫니 이러면 이제 여러분들 입장에서 파이썬이 쉽죠. 파이썬이 쉽고 똑같은 심지어는 이제 언어별 차이는 거의 없으면서 속도는 이제 기존 것보다 더 2배 이상 빠르기 때문에 당연히 특별한 일 없으면 당연히 스파트 SK로 넘어갈 텐데 근데 왜 이렇게 넘어갔냐 제가 계속 말씀드리지만 우리 수업은 한 학기 수업이지만 실제로는 15년이죠. 지금 빅데이터가 등장한 게 2006년도라고 이거죠. 예. 2006년도이기 때문에 저희가 한 15년에서 지금 17년 정도 되고 있는 거죠." },
    { id: 10, text: "17년 역사를 지금 저희가 짧게 이제 한 학기 동안 배우기 때문에 한 주가 사실은 한 5년 된다는 이야기야 이거죠. 초반에는 하둡이 이제 유행을 탄 거죠. 하둡이라는 게 빅데이터고 이제 그러다가 이제 스파크라는 놈이 2010년도 직전 2009년 이 정도 나올 거 아니에요 그때 이제 red라는 거 스파트 red로 돌려봤더니 하드보다 또 두 배 빠르니까 사람들이 뭐 원래 공식 사이트 기준으로 100배 빠르다 이러고 있는데 그래서 사람들이 이게 뭐냐 하는 거잖아요. 그래서 제가 red의 특징 세 가지 이런 거 실습한 거잖아." },
    { id: 11, text: "그런데 또 한 몇 년 지나가지고 2010년 중반 거죠. 2010년 중반 이후에 이제 스파트 에스q이라는 게 등장한 거잖아. 이게 또 기존의 또 red보다 또 두 배 빠르네 이러니까 사람들이 이렇게 쭉 가잖아 이거죠. 이렇게 이제 뭐라고 해야 되나 트렌드가 이런 식으로 이제 간다는 이야기죠. 역시 여러분들 제가 빅데이터 말고 저기 AI 쪽도 이야기를 드렸죠. AI도 지금 나온 지가 지금 역시 2016년도에 나왔죠. 2014년도에 나온 거구나 AI 말이에요. AI에 저기 딥러닝 해보면 딥러닝도 이제 우리가 보통 통상적으로 AI 충격이다 이러는 게 저기 그거 알파고 아니 알파고가 2014년도죠. 그럼 지금 이제 거의 딱 10년 됐죠. 10년이 됐는데 요 10년 사이에 초창기에는 뭐죠?" },
    { id: 12, text: "거죠. 그리고 텐서 플로우 2야 이거죠. 그래서 텐서플로우 2가 나오면서 이제는 좀 더 쉽게 AI를 구현할 수 있게 됐다는 거죠. 그래서 요즘은 텐서플로우보다는 캐라스를 더 많이 쓰는 추세입니다. 이렇게 기술이 발전하면서 더 쉽게 접근할 수 있는 도구들이 나오고 있는 거죠. 그래서 오늘은 스파크 SQL에 대해서 좀 더 깊이 있게 다뤄보도록 하겠습니다." },
  ];
  
  export const dummySummary = [
    { id: 1, text: "중간고사는 4월 26일 12:00부터 12:50까지이며, 과제는 내일부터 다음 주까지의 수업 내용을 포함합니다. 시험 형식은 다양한 유형으로 구성되며, 일반적으로 12문제가 출제되며 총 100점입니다." },
    { id: 2, text: "시험 시간에는 15분 이후 입실이 불가능하며, 지각 시 입실이 허용되지 않음. 중간고사는 수업 내용을 포함한 다음 주까지의 내용으로 구성됨. 중간고사에 공지되지 않은 사항 주의." },
    { id: 3, text: "다음 주까지 하나의 슬라이드로 묶은 이유는 원래 이번 주와 다음 주에 스파크와 하둡 설치를 진행하려 했으나, 문제가 발생했기 때문입니다. 특히, 애플 실리콘 노트북을 사용하는 경우 가상 머신(버추얼박스)이 제대로 작동하지 않는 문제가 있어 계획에 차질이 생겼습니다." },
    { id: 4, text: "애플 실리콘(M1, M2, M3)은 리눅스 설치에 어려움이 있었습니다. 최근에서야 M1에 리눅스를 네이티브로 설치할 수 있는 방법이 나왔지만, 여전히 가상화(버추얼박스 등)는 안정적이지 않습니다. 이 수업은 리눅스 기반으로 진행되어야 하기 때문에 도커를 제외한 다른 대안이 거의 없으며, 애플 사용자는 별도로 설치 방법을 알아야 합니다." },
    { id: 5, text: "기존에는 버추얼박스를 설치하면 쉽게 진행할 수 있었지만, 작년부터 애플 실리콘에서는 이 방법이 거의 불가능해졌습니다. 애플과 인텔 기반 노트북 사용자들을 따로 분리해서 진행해야 하는 상황이 되었습니다. 그래서 수업을 두 번 더 해야 하고, 설치 과정에 시간이 걸려 중간고사 이후로 설치 순서를 변경했습니다. 오늘과 다음 주에는 스파크 SQL에 대해 다룰 것이며, 이는 스파크의 주요 기능으로 빅데이터 분석에서 중요한 역할을 합니다." },
    { id: 6, text: "중간고사 이후에 설치와 관련된 부분을 진행할 예정입니다. 클라우드를 사용할 수도 있지만, 수업의 중요한 내용은 직접 컴퓨터에 설치하고 환경을 만드는 것이므로 그렇게 진행할 것입니다. 오늘은 스파크 SQL의 첫 번째 부분을 다루며, 스파크 SQL과 스파크 RDD의 차이에 대해 설명할 예정입니다." },
    { id: 7, text: "스파크의 파이썬과 스칼라 버전의 속도 차이에 대해 설명한 그래프를 보여드린 적이 있습니다. 원래 오늘 과제를 내려고 했으나, 중간고사와 겹쳐 부담이 될 수 있어 다음 주에 과제를 내기로 했습니다. 지난 시간에는 스칼라와 파이썬으로 스파크를 사용하여 워드 카운트 예제를 실습했습니다." },
    { id: 8, text: "벤치마크 결과, 스칼라로 스파크를 돌리는 속도가 파이썬보다 약 2배 빠릅니다. 예를 들어, 스칼라 스파크 RDD로 작업하면 4초가 걸리지만, 파이썬 스파크 RDD로는 9초가 걸립니다. 오늘 배울 스파크 SQL을 사용하면 속도가 더 빨라져서 약 2초가 걸립니다. 따라서 동일한 조건에서는 스칼라로 스파크를 돌리는 것이 더 효율적입니다." },
    { id: 9, text: "지난 시간에 배운 RDD보다 스파크 SQL을 사용하면 속도가 약 2배 빨라집니다. 공식 사이트에서도 이 차이를 확인할 수 있습니다. 스칼라와 파이썬 간의 속도 차이는 거의 없지만, 파이썬이 배우기 쉽기 때문에 많은 사람들이 파이썬을 선택합니다. 스파크 SQL의 성능이 뛰어나므로, 특별한 이유가 없다면 스파크 SQL로 넘어가는 것이 합리적입니다. 빅데이터는 2006년부터 등장했으며, 수업은 이를 반영하여 진행됩니다." },
    { id: 10, text: "빅데이터의 17년 역사를 한 학기 동안 배우기 때문에, 한 주가 약 5년에 해당한다고 볼 수 있습니다. 초반에는 하둡이 유행했지만, 2009년경에 스파크가 등장하면서 RDD로 돌리면 하둡보다 두 배 빠르다는 사실이 알려졌습니다. 공식 사이트에서는 스파크가 하둡보다 100배 빠르다고 주장하기도 합니다. 이에 따라 RDD의 특징과 관련된 실습을 진행했습니다." },
    { id: 11, text: "2010년 중반 이후에 스파크 SQL이 등장하면서 기존의 RDD보다 속도가 두 배 빠르다는 사실이 알려졌습니다. 이러한 트렌드는 계속 변화하고 있습니다. 빅데이터뿐만 아니라 AI 분야도 2014년에 딥러닝이 등장하면서 큰 변화를 겪었고, 특히 2014년 알파고의 등장으로 AI 충격이 일어났습니다. 현재는 딥러닝이 등장한 지 약 10년이 되었습니다." },
    { id: 12, text: "알파고나 AI를 하려면 텐서플로우를 사용해야 했지만, 몇 년이 지나면서 텐서플로우가 복잡해졌습니다. 이에 따라 캐라스로의 전환이 이루어졌으며, 특히 텐서플로우 2가 주목받았습니다. 이제는 캐라스를 사용하여 AI를 학습하는 추세입니다." },
  ];

  export const dummyQuestion = [
    { id: 1, text: "빅데이터의 저장 문제와 이를 해결하기 위한 HDFS 이론 및 고가용성 개념을 설명하세요." },
    { id: 2, text: "액티브-스탠바이 구조와 액티브-액티브 구조의 차이점을 설명하고, 금융권에서 액티브-액티브 시스템을 선호하는 이유를 기술하세요." },
    { id: 3, text: "스파크 RDD의 세 가지 주요 특징인 읽기 전용(Reid-Only), 장애 내성(Fault-Tolerant), 지연 로딩(Lazy Loading)을 설명하세요." },
    { id: 4, text: "스파크 RDD의 변환 연산과 행동 연산의 차이점을 설명하세요." },
    { id: 5, text: "스파크 RDD에서 캐시(Caching)와 체크포인트(Checkpointing)의 차이점을 설명하세요." },
    { id: 6, text: "스파크 RDD의 파티셔닝(Patitioning)과 셔플링(Shuffling)의 차이점을 설명하세요." },
    { id: 7, text: "스파크 RDD에서 넓은 변환(Wide Transformation)과 좁은 변환(Narrow Transformation)의 차이점을 설명하세요." },
    { id: 8, text: "스파크 RDD의 액션(Action) 연산과 트랜스포메이션(Transformation) 연산의 차이점을 설명하세요." },
    { id: 9, text: "스파크 RDD에서 파티셔닝의 중요성과 이를 활용한 성능 최적화 방법을 설명하세요." },
    { id: 10, text: "RDD의 구조에서 리니지(Lineage)의 개념과 이를 활용한 데이터 복구 방법을 설명하세요." },
  ];
  
  export const dummyAnswer = Array(10).fill("");


  export const dummyAiTutor=  [
    {id:1, text: "빅데이터 저장 문제는 방대한 데이터를 효율적으로 관리하고 처리하는 데 어려움이 따르는 상황입니다. HDFS는 데이터를 여러 노드에 분산 저장하고, 복제하여 데이터 손실을 방지하고 성능을 향상시킵니다. HDFS는 데이터를 블록 단위로 나누고, 각 블록을 여러 노드에 복제하여 저장함으로써 데이터 복구를 쉽게 합니다. 고가용성은 시스템이 항상 동작하도록 보장하는 개념으로, HDFS에서는 네임노드의 이중화를 통해 장애 시에도 데이터 접근이 가능하게 합니다. 이를 통해 빅데이터를 안전하고 효율적으로 저장하고 관리할 수 있습니다."},
    {id:2, text: "액티브-스탠바이 구조는 한 시스템이 작동 중일 때 다른 시스템이 대기 상태에 있다가 장애 시 작동하는 방식이고, 액티브-액티브 구조는 두 시스템이 동시에 작동하며 부하를 분산한다."},
    {id:3, text: "스파크 RDD는 읽기 전용으로 한 번 생성되면 변경되지 않으며, 장애 내성을 통해 데이터를 여러 노드에 복제하여 장애 시 자동으로 복구한다."},
    {id:4, text: "RDD의 구조에서 리니지(Lineage)의 개념과 이를 활용한 데이터 복구 방법을 설명하세요."},
    {id:5, text: "스파크 SQL은 스파크 RDD보다 더 빠른 성능을 제공하며, SQL 쿼리를 사용하여 데이터를 처리할 수 있습니다. 이는 데이터 분석 작업을 더 쉽게 하고 효율적으로 만듭니다."},
    {id:6, text: "스파크 SQL은 데이터프레임과 데이터셋 API를 제공하여 구조화된 데이터를 처리하는 데 유용합니다. 이는 RDD보다 더 높은 수준의 추상화를 제공하여 사용자가 더 쉽게 데이터를 조작할 수 있게 합니다."},
    {id:7, text: "스파크 SQL은 다양한 데이터 소스와 통합할 수 있으며, Hive, Avro, Parquet, ORC 등과 같은 형식을 지원합니다. 이를 통해 다양한 데이터 형식을 쉽게 처리할 수 있습니다."},
    {id:8, text: "스파크 SQL은 Catalyst 옵티마이저를 사용하여 쿼리 성능을 최적화합니다. 이는 쿼리 실행 계획을 자동으로 생성하고 최적화하여 성능을 향상시킵니다."},
    {id:9, text: "스파크 SQL은 사용자 정의 함수(UDF)를 지원하여 사용자가 자신의 로직을 SQL 쿼리 내에서 사용할 수 있게 합니다. 이를 통해 복잡한 데이터 처리 작업을 더 유연하게 수행할 수 있습니다."},
    {id:10, text: "스파크 SQL은 스파크 스트리밍과 통합되어 실시간 데이터 처리를 지원합니다. 이를 통해 실시간 데이터 분석 및 처리를 효율적으로 수행할 수 있습니다."}
  ]

  export const dummyMyAnswer = [
    {id:1, text: "HDFS는 빅데이터를 분산 저장하고 복제하여 데이터 손실을 방지하고, 고가용성을 통해 접근 속도를 높인다."},
    {id:2, text: "액티브-스탠바이 구조는 한 시스템이 작동 중일 때 다른 시스템이 대기 상태에 있다가 장애 시 작동하는 방식이고, 액티브-액티브 구조는 두 시스템이 동시에 작동하며 부하를 분산한다."},
    {id:3, text: "스파크 RDD는 읽기 전용으로 한 번 생성되면 변경되지 않으며, 장애 내성을 통해 데이터를 여러 노드에 복제하여 장애 시 자동으로 복구한다."},
    { id: 4, text: "변환 연산은 새로운 RDD를 생성하고, 행동 연산은 실제로 연산을 수행하여 결과를 반환한다." },
    { id: 5, text: "캐시는 RDD를 메모리에 저장하여 반복 사용 시 성능을 높이고, 체크포인트는 RDD를 디스크에 저장하여 장애 복구를 돕는다." },
    { id: 6, text: "파티셔닝은 데이터를 분할하여 저장하고, 셔플링은 데이터를 재분배하여 연산을 수행한다." },
    { id: 7, text: "넓은 변환은 여러 파티션에 걸쳐 데이터를 변환하고, 좁은 변환은 단일 파티션 내에서 데이터를 변환한다." },
    { id: 8, text: "액션 연산은 실제 결과를 반환하고, 트랜스포메이션 연산은 새로운 RDD를 생성한다." },
    { id: 9, text: "파티셔닝은 데이터 분산을 최적화하여 성능을 높이고, 적절한 파티셔닝 전략을 통해 연산 속도를 개선할 수 있다." },
    { id: 10, text: "RDD의 리니지는 RDD의 생성 및 변환 과정을 추적하는 개념으로, DAG(Directed Acyclic Graph) 형태로 표현된다. 이는 RDD가 어떻게 만들어졌는지를 기록하여 장애 시 데이터를 복구하는 데 중요한 역할을 한다. 리니지를 통해 RDD는 데이터를 물리적으로 저장하지 않고도 효율적인 복구와 무결성을 유지할 수 있다. 이를 통해 Spark는 대규모 분산 데이터 처리에서 높은 신뢰성과 성능을 제공한다." },
  ]

